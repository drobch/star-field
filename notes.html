<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="HandheldFriendly" content="true">
    <title>drobch | notes</title>

    <link rel="icon" type="image/png" href="favicon.ico">
    <link rel="stylesheet" href="css/star.css">
    <link rel="stylesheet" href="css/media.css">
    <link rel="stylesheet" href="css/squares.css">
    <link rel="stylesheet" href="css/font-awesome.min.css">


    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=sunburst"></script>
</head>

<body>
<script src="https://cdn.polyfill.io/v2/polyfill.min.js"></script>
<script src="js/script.js"></script>
<header>
    <logo>
        <a href="https://drobch.github.io/star-field/">.drobch</a>
    </logo>

    <nav>
        <button type="button" onclick="prev()" id="prevBtn">Prev</button>
        <button type="button" onclick="location.href='star-field.html'" > Home </button>
        <button type="button" onclick="next()" id="nextBtn"> Next </button>
    </nav>
</header>

<content>
    <section class="visible">

        <h3>
            How to make carousel work
        </h3>

        <h5>This is one of possible variants how to make js part of the carousel like in Bootstrap with jquery and lodash. The code will work for all carousels you have on a page.</h5>
        <pre class="prettyprint">

  const carousel = $('[data-ride="carousel"]');
  const slides = carousel.find('.carousel-item');
  const maxIndex = slides.length - 1;
  let currentIndex = _.findIndex(slides, slide => $(slide).hasClass('active'));
  const handlerGenerator = next => () => {
    const newCurrentIndex = next(currentIndex);
    slides.removeClass('active');
    slides.each((i, element) => {
      const current = $(element);
      if (i === newCurrentIndex) {
        current.addClass('active');
      }
    });
    currentIndex = newCurrentIndex;
  };
  const prev = carousel.find('[data-slide="prev"]');
  prev.click(handlerGenerator(i => (i === 0 ? maxIndex : i - 1)));
  const next = carousel.find('[data-slide="next"]');
  next.click(handlerGenerator(i => (maxIndex === i ? 0 : i + 1)));


        </pre>

        <time datetime="2017-12-12">2017-11-13</time>

    </section>
    <section class="hidden">
        <h3>
            What is a closure?
        </h3>

        <h5>Closures’ Rules and Side Effects</h5>

        <p>
            A closure is an inner function that has access to the outer (enclosing) function’s variables—scope chain. The closure has three scope chains: it has access to its own scope (variables defined between its curly brackets), it has access to the outer function’s variables, and it has access to the global variables.<br>

            The inner function has access not only to the outer function’s variables, but also to the outer function’s parameters. Note that the inner function cannot call the outer function’s arguments object, however, even though it can call the outer function’s parameters directly. <br>
        </p>
        <div>
            <img src="https://www.kirupa.com/images/definition_closure_72.png" alt="closure example code">
        </div>

        <p>
            Closures allow JavaScript programmers to write better code. Creative, expressive, and concise. We frequently use closures in JavaScript, and, no matter your JavaScript experience, you will undoubtedly encounter them time and again. Sure, closures might appear complex and beyond your scope, but after you read this section, closures will be much more easily understood and thus more appealing for your everyday JavaScript programming tasks.
        </p>
        <time datetime="2017-12-12">2017-12-12</time>
    </section>
    <section class="hidden">
        <h3>
            What is a closure?
        </h3>

        <h5>Why is this question so popular?</h5>

        <p>
            The inner function will have access to the variables in the outer function scope, even after the outer function has returned.
        </p>
        <p>
            A solid understanding of functional/block scope, anonymous functions, closures, and IIFE’s will definitely make you a better JavaScript developer and help you out in future interviews.
        </p>

        <time datetime="2017-12-12">2017-12-12</time>
    </section>
    <section class="hidden">
        <h3>
            What is a closure?
        </h3>

        <h5>Closures’ Rules and Side Effects</h5>

        <p>
            One of the most important and ticklish features with closures is that the inner function still has access to the outer function’s variables even after the outer function has returned. Yep, you read that correctly. When functions in JavaScript execute, they use the same scope chain that was in effect when they were created. This means that even after the outer function has returned, the inner function still has access to the outer function’s variables. Therefore, you can call the inner function later in your program.
        </p>

        <p>Closures store references to the outer function’s variables; they do not store the actual value.  Closures get more interesting when the value of the outer function’s variable changes before the closure is called. </p>

        <p>
             Because closures have access to the updated values of the outer function’s variables, they can also lead to bugs when the outer function’s variable changes with a for loop.
        </p>
        <time datetime="2017-12-12">2017-12-12</time>
    </section>
</content>

<footer>
    <div class="foo">
        <a href="https://github.com/drobch">
            <i class="fa fa-github fa-lg" aria-hidden="true"></i>
        </a>
    </div>
    <div class="foo">
        <a href="https://vk.com/id66905289">
            <i class="fa fa-vk" aria-hidden="true"></i>
        </a>
    </div>
    <div class="foo">
        <a href="mail.html">
            <i class="fa fa-envelope" aria-hidden="true"></i>
        </a>
    </div>
</footer>

</body>

</html>